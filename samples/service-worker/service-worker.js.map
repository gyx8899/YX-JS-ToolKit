{"version":3,"sources":["service-worker.es6"],"names":[],"mappings":";;AAAA;AACA;AACA;AACA,IAAM,WAAW,aAAjB;AACA,IAAM,UAAU,SAAhB;;AAEA;AACA,IAAM,gBAAgB,CACpB,YADoB,EAEpB,IAFoB,EAEd;AACN,YAHoB,EAIpB,UAJoB,CAAtB;;AAOA;AACA,KAAK,gBAAL,CAAsB,SAAtB,EAAiC,iBAAS;AACxC,QAAM,SAAN,CACE,OAAO,IAAP,CAAY,QAAZ,EACG,IADH,CACQ;AAAA,WAAS,MAAM,MAAN,CAAa,aAAb,CAAT;AAAA,GADR,EAEG,IAFH,CAEQ,KAAK,WAAL,EAFR,CADF;AAKD,CAND;;AAQA;AACA,KAAK,gBAAL,CAAsB,UAAtB,EAAkC,iBAAS;AACzC,MAAM,gBAAgB,CAAC,QAAD,EAAW,OAAX,CAAtB;AACA,QAAM,SAAN,CACE,OAAO,IAAP,GAAc,IAAd,CAAmB,sBAAc;AAC/B,WAAO,WAAW,MAAX,CAAkB;AAAA,aAAa,CAAC,cAAc,QAAd,CAAuB,SAAvB,CAAd;AAAA,KAAlB,CAAP;AACD,GAFD,EAEG,IAFH,CAEQ,0BAAkB;AACxB,WAAO,QAAQ,GAAR,CAAY,eAAe,GAAf,CAAmB,yBAAiB;AACrD,aAAO,OAAO,MAAP,CAAc,aAAd,CAAP;AACD,KAFkB,CAAZ,CAAP;AAGD,GAND,EAMG,IANH,CAMQ;AAAA,WAAM,KAAK,OAAL,CAAa,KAAb,EAAN;AAAA,GANR,CADF;AASD,CAXD;;AAaA;AACA;AACA;AACA,KAAK,gBAAL,CAAsB,OAAtB,EAA+B,iBAAS;AACtC;AACA,MAAI,MAAM,OAAN,CAAc,GAAd,CAAkB,UAAlB,CAA6B,KAAK,QAAL,CAAc,MAA3C,CAAJ,EAAwD;AACtD,UAAM,WAAN,CACE,OAAO,KAAP,CAAa,MAAM,OAAnB,EAA4B,IAA5B,CAAiC,0BAAkB;AACjD,UAAI,cAAJ,EAAoB;AAClB,eAAO,cAAP;AACD;;AAED,aAAO,OAAO,IAAP,CAAY,OAAZ,EAAqB,IAArB,CAA0B,iBAAS;AACxC,eAAO,MAAM,MAAM,OAAZ,EAAqB,IAArB,CAA0B,oBAAY;AAC3C;AACA,iBAAO,MAAM,GAAN,CAAU,MAAM,OAAhB,EAAyB,SAAS,KAAT,EAAzB,EAA2C,IAA3C,CAAgD,YAAM;AAC3D,mBAAO,QAAP;AACD,WAFM,CAAP;AAGD,SALM,CAAP;AAMD,OAPM,CAAP;AAQD,KAbD,CADF;AAgBD;AACF,CApBD","file":"service-worker.js","sourcesContent":["// Names of the two caches used in this version of the service worker.\r\n// Change to v2, etc. when you update any of the local resources, which will\r\n// in turn trigger the install event again.\r\nconst PRECACHE = 'precache-v1';\r\nconst RUNTIME = 'runtime';\r\n\r\n// A list of local resources we always want to be cached.\r\nconst PRECACHE_URLS = [\r\n  'index.html',\r\n  './', // Alias for index.html\r\n  'styles.css',\r\n  'index.js'\r\n];\r\n\r\n// The install handler takes care of precaching the resources we always need.\r\nself.addEventListener('install', event => {\r\n  event.waitUntil(\r\n    caches.open(PRECACHE)\r\n      .then(cache => cache.addAll(PRECACHE_URLS))\r\n      .then(self.skipWaiting())\r\n  );\r\n});\r\n\r\n// The activate handler takes care of cleaning up old caches.\r\nself.addEventListener('activate', event => {\r\n  const currentCaches = [PRECACHE, RUNTIME];\r\n  event.waitUntil(\r\n    caches.keys().then(cacheNames => {\r\n      return cacheNames.filter(cacheName => !currentCaches.includes(cacheName));\r\n    }).then(cachesToDelete => {\r\n      return Promise.all(cachesToDelete.map(cacheToDelete => {\r\n        return caches.delete(cacheToDelete);\r\n      }));\r\n    }).then(() => self.clients.claim())\r\n  );\r\n});\r\n\r\n// The fetch handler serves responses for same-origin resources from a cache.\r\n// If no response is found, it populates the runtime cache with the response\r\n// from the network before returning it to the page.\r\nself.addEventListener('fetch', event => {\r\n  // Skip cross-origin requests, like those for Google Analytics.\r\n  if (event.request.url.startsWith(self.location.origin)) {\r\n    event.respondWith(\r\n      caches.match(event.request).then(cachedResponse => {\r\n        if (cachedResponse) {\r\n          return cachedResponse;\r\n        }\r\n\r\n        return caches.open(RUNTIME).then(cache => {\r\n          return fetch(event.request).then(response => {\r\n            // Put a copy of the response in the runtime cache.\r\n            return cache.put(event.request, response.clone()).then(() => {\r\n              return response;\r\n            });\r\n          });\r\n        });\r\n      })\r\n    );\r\n  }\r\n});"]}