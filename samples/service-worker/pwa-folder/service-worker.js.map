{"version":3,"sources":["service-worker.es6"],"names":[],"mappings":";;AAAA;AACA;AACA;AACA,IAAM,WAAW,aAAjB;AACA,IAAM,UAAU,SAAhB;;AAEA;AACA,IAAM,gBAAgB,CACrB,YADqB,EAErB,IAFqB,EAEf;AACN,YAHqB,EAIrB,UAJqB,CAAtB;;AAOA;AACA,KAAK,gBAAL,CAAsB,SAAtB,EAAiC,iBAAS;AACzC,OAAM,SAAN,CACE,OAAO,IAAP,CAAY,QAAZ,EACG,IADH,CACQ;AAAA,SAAS,MAAM,MAAN,CAAa,aAAb,CAAT;AAAA,EADR,EAEG,IAFH,CAEQ,KAAK,WAAL,EAFR,CADF;AAKA,CAND;;AAQA;AACA,KAAK,gBAAL,CAAsB,UAAtB,EAAkC,iBAAS;AAC1C,KAAM,gBAAgB,CAAC,QAAD,EAAW,OAAX,CAAtB;AACA,OAAM,SAAN,CACE,OAAO,IAAP,GAAc,IAAd,CAAmB,sBAAc;AAChC,SAAO,WAAW,MAAX,CAAkB;AAAA,UAAa,CAAC,cAAc,QAAd,CAAuB,SAAvB,CAAd;AAAA,GAAlB,CAAP;AACA,EAFD,EAEG,IAFH,CAEQ,0BAAkB;AACzB,SAAO,QAAQ,GAAR,CAAY,eAAe,GAAf,CAAmB,yBAAiB;AACtD,UAAO,OAAO,MAAP,CAAc,aAAd,CAAP;AACA,GAFkB,CAAZ,CAAP;AAGA,EAND,EAMG,IANH,CAMQ;AAAA,SAAM,KAAK,OAAL,CAAa,KAAb,EAAN;AAAA,EANR,CADF;AASA,CAXD;;AAaA;AACA;AACA;AACA,KAAK,gBAAL,CAAsB,OAAtB,EAA+B,iBAAS;AACvC;AACA,KAAI,MAAM,OAAN,CAAc,GAAd,CAAkB,UAAlB,CAA6B,KAAK,QAAL,CAAc,MAA3C,CAAJ,EACA;AACC,QAAM,WAAN,CACE,OAAO,KAAP,CAAa,MAAM,OAAnB,EAA4B,IAA5B,CAAiC,0BAAkB;AAClD,OAAI,cAAJ,EACA;AACC,WAAO,cAAP;AACA;;AAED,UAAO,OAAO,IAAP,CAAY,OAAZ,EAAqB,IAArB,CAA0B,iBAAS;AACzC,WAAO,MAAM,MAAM,OAAZ,EAAqB,IAArB,CAA0B,oBAAY;AAC5C;AACA,YAAO,MAAM,GAAN,CAAU,MAAM,OAAhB,EAAyB,SAAS,KAAT,EAAzB,EAA2C,IAA3C,CAAgD,YAAM;AAC5D,aAAO,QAAP;AACA,MAFM,CAAP;AAGA,KALM,CAAP;AAMA,IAPM,CAAP;AAQA,GAdD,CADF;AAiBA;AACD,CAtBD","file":"service-worker.js","sourcesContent":["// Names of the two caches used in this version of the service worker.\r\n// Change to v2, etc. when you update any of the local resources, which will\r\n// in turn trigger the install event again.\r\nconst PRECACHE = 'precache-v1';\r\nconst RUNTIME = 'runtime';\r\n\r\n// A list of local resources we always want to be cached.\r\nconst PRECACHE_URLS = [\r\n\t'index.html',\r\n\t'./', // Alias for index.html\r\n\t'styles.css',\r\n\t'index.js'\r\n];\r\n\r\n// The install handler takes care of precaching the resources we always need.\r\nself.addEventListener('install', event => {\r\n\tevent.waitUntil(\r\n\t\t\tcaches.open(PRECACHE)\r\n\t\t\t\t\t.then(cache => cache.addAll(PRECACHE_URLS))\r\n\t\t\t\t\t.then(self.skipWaiting())\r\n\t);\r\n});\r\n\r\n// The activate handler takes care of cleaning up old caches.\r\nself.addEventListener('activate', event => {\r\n\tconst currentCaches = [PRECACHE, RUNTIME];\r\n\tevent.waitUntil(\r\n\t\t\tcaches.keys().then(cacheNames => {\r\n\t\t\t\treturn cacheNames.filter(cacheName => !currentCaches.includes(cacheName));\r\n\t\t\t}).then(cachesToDelete => {\r\n\t\t\t\treturn Promise.all(cachesToDelete.map(cacheToDelete => {\r\n\t\t\t\t\treturn caches.delete(cacheToDelete);\r\n\t\t\t\t}));\r\n\t\t\t}).then(() => self.clients.claim())\r\n\t);\r\n});\r\n\r\n// The fetch handler serves responses for same-origin resources from a cache.\r\n// If no response is found, it populates the runtime cache with the response\r\n// from the network before returning it to the page.\r\nself.addEventListener('fetch', event => {\r\n\t// Skip cross-origin requests, like those for Google Analytics.\r\n\tif (event.request.url.startsWith(self.location.origin))\r\n\t{\r\n\t\tevent.respondWith(\r\n\t\t\t\tcaches.match(event.request).then(cachedResponse => {\r\n\t\t\t\t\tif (cachedResponse)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn cachedResponse;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn caches.open(RUNTIME).then(cache => {\r\n\t\t\t\t\t\treturn fetch(event.request).then(response => {\r\n\t\t\t\t\t\t\t// Put a copy of the response in the runtime cache.\r\n\t\t\t\t\t\t\treturn cache.put(event.request, response.clone()).then(() => {\r\n\t\t\t\t\t\t\t\treturn response;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t});\r\n\t\t\t\t})\r\n\t\t);\r\n\t}\r\n});"]}